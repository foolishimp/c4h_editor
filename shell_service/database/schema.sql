-- Schema for C4H Preferences Shell Service Database
-- Designed for compatibility with SQLite and PostgreSQL where possible

-- Table for storing available microfrontend app definitions
CREATE TABLE IF NOT EXISTS available_apps (
    id TEXT PRIMARY KEY NOT NULL,          -- Unique identifier (e.g., 'config-selector-workflows')
    name TEXT NOT NULL,                    -- Display name (e.g., 'Workflow Config Manager')
    scope TEXT NOT NULL,                   -- Module Federation scope
    module TEXT NOT NULL,                  -- Module Federation module name
    url TEXT,                              -- URL for remoteEntry.js
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Table for storing service endpoint configurations
CREATE TABLE IF NOT EXISTS service_endpoints (
    id TEXT PRIMARY KEY NOT NULL DEFAULT 'default', -- Usually just one row with id 'default'
    job_config_service_url TEXT,           -- URL for the Job/Config Service API
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Table for storing user-specific frame (tab) preferences
CREATE TABLE IF NOT EXISTS frames (
    -- Use TEXT for id assuming UUIDs might be generated by the app
    id TEXT PRIMARY KEY NOT NULL,
    user_id TEXT NOT NULL,                 -- Identifier for the user these frames belong to
    name TEXT NOT NULL,                    -- Display name of the frame (tab)
    "order" INTEGER NOT NULL DEFAULT 0,    -- Display order (using quotes for reserved word compatibility)
    -- Store JSON as TEXT for SQLite compatibility
    assigned_apps TEXT NOT NULL DEFAULT '[]', -- JSON array of AppAssignment objects {appId: string}
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Optional: Indexes can improve query performance
CREATE INDEX IF NOT EXISTS idx_frames_user_id ON frames (user_id);
CREATE INDEX IF NOT EXISTS idx_frames_user_order ON frames (user_id, "order");

-- Optional: Triggers to automatically update 'updated_at' timestamp
-- Trigger syntax varies significantly between SQLite and PostgreSQL.
-- It's often simpler to manage 'updated_at' in the application layer (CRUD functions).

/* -- Example PostgreSQL Trigger --
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_available_apps_modtime BEFORE UPDATE ON available_apps FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
CREATE TRIGGER update_service_endpoints_modtime BEFORE UPDATE ON service_endpoints FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
CREATE TRIGGER update_frames_modtime BEFORE UPDATE ON frames FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
*/

/* -- Example SQLite Trigger --
CREATE TRIGGER update_available_apps_updated_at AFTER UPDATE ON available_apps
BEGIN
    UPDATE available_apps SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
END;
-- Similar triggers for other tables...
*/